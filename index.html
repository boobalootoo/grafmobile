Okay, let's modify the code to replace the WASD key controls with a virtual joystick.<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Graffiti Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; position: relative; /* Make sure body is a positioning context */ }
        canvas { display: block; }
        #hand {
            position: absolute;
            width: 130px;
            height: 170px;
            pointer-events: none;
            display: none;
            top: 0;
            left: 0;
            z-index: 10;
        }
        .joystick {
            position: absolute;
            bottom: 20px;  /* Adjust as necessary */
            left: 20px;    /* Adjust as necessary */
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: rgba(100, 100, 100, 0.5); /* Semi-transparent grey */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000; /* Ensure the joystick is above other elements */
        }

        .joystick-handle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(200, 200, 200, 0.7); /* Lighter semi-transparent grey */
            cursor: grab;
            position: relative; /* Important for positioning the handle */
        }

        .joystick-handle:active {
            cursor: grabbing;
        }

    </style>
</head>
<body>
    <img id="hand" src="https://raw.githubusercontent.com/boobalootoo/HANDS/main/hand.png" alt="Hand" />
    <div class="joystick" id="joystick">
        <div class="joystick-handle" id="joystick-handle"></div>
    </div>
    <script>
        let scene, camera, renderer;
        let player, wall, box;
        let currentColor = "#ff0000";
        let isDrawing = false;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let rotateLeft = false;
        let rotateRight = false;
        let rotateUp = false;
        let rotateDown = false;
        let rotationSpeed = 0.02;
        let cameraRotationY = 0;
        let cameraRotationX = 0;
        let sprayPoints = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let cameraTarget = new THREE.Vector3();
        const targetDistance = 5;
        const sprayRadius = 0.1;
        let pointGeometry;
        let pointMaterial;
        let numPoints = 10;
        let handElement;
        let pickedCylinder = null;
        let originalCylinderParent = null;
        let originalCylinderPosition = null;
        let cylinders = [];
        let isLeftMouseDown = false; // Track left mouse button state
        let lastHandPosition = { x: 0, y: 0 };  // To track hand movement
        let shakeTimeout;
        let isShaking = false; //track shaking state

        //Joystick Variables
        let joystick = null;
        let joystickHandle = null;
        let joystickCenter = { x: 0, y: 0 };
        let isDraggingJoystick = false;
        let joystickInput = { x: 0, y: 0 }; // Normalized input from joystick

        // Sound Effects (Web Audio API)
        const soundFiles = {
            capOff: "https://boobalootoo.github.io/HANDS/200375__cbakos__spray-paint-cap-off.wav",
            spray: "https://boobalootoo.github.io/HANDS/460408__jay_you__spray-painting.wav",
            shake: "https://boobalootoo.github.io/HANDS/523005__dobroide__20200502spraycanshake.wav",
            drop: "https://boobalootoo.github.io/HANDS/700149__piotrkier__dropping-spray-paint-can.wav"
        };

        let soundBuffers = {};
        let audioContext;
        let sprayingSoundSource = null; // Keep track of the spray sound source
        let shakingSoundSource = null;

        function loadSound(url, callback) {
            const request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.responseType = 'arraybuffer';
            request.onload = function () {
                audioContext.decodeAudioData(request.response, callback, function (error) {
                    console.error('Error decoding audio data:', error);
                });
            };
            request.send();
        }

        function playSound(soundName) {
            if (soundBuffers[soundName]) {
                const source = audioContext.createBufferSource();
                source.buffer = soundBuffers[soundName];
                source.connect(audioContext.destination);
                source.start(0);
            }
        }

        function playSpraySound() {
            if (isLeftMouseDown) {
                if (!sprayingSoundSource) {
                    sprayingSoundSource = audioContext.createBufferSource();
                    sprayingSoundSource.buffer = soundBuffers['spray'];
                    sprayingSoundSource.loop = true;
                    sprayingSoundSource.connect(audioContext.destination);
                    sprayingSoundSource.start(0);
                }
            } else {
                if (sprayingSoundSource) {
                    sprayingSoundSource.stop();
                    sprayingSoundSource = null;
                }
            }
        }

        function playShakingSound() {
            if (isShaking) {
                if (!shakingSoundSource) {
                    shakingSoundSource = audioContext.createBufferSource();
                    shakingSoundSource.buffer = soundBuffers['shake'];
                    shakingSoundSource.loop = true;
                    shakingSoundSource.connect(audioContext.destination);
                    shakingSoundSource.start(0);
                }
            } else {
                if (shakingSoundSource) {
                    shakingSoundSource.stop();
                    shakingSoundSource = null;
                }
            }
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            player = new THREE.Object3D();
            player.position.set(0, 1.5, 5);
            scene.add(player);

            camera.position.set(0, 1.5, 0);
            cameraTarget.set(0, 1.5, -5);
            camera.lookAt(cameraTarget);
            player.add(camera);

            let groundGeometry = new THREE.PlaneGeometry(100, 100);
            let groundMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, side: THREE.DoubleSide });
            let ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            let wallGeometry = new THREE.PlaneGeometry(10, 5);
            let wallMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, side: THREE.DoubleSide });
            wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(0, 2.5, -3);
            scene.add(wall);

            // Create geometry for the open-top box directly
            const boxWidth = 1;
            const boxHeight = 1;
            const boxDepth = 1;
            const brownColor = 0xA0522D;

            let openTopBoxGeometry = new THREE.BufferGeometry();
            const positions = [
                // Bottom face
                -boxWidth / 2, 0, -boxDepth / 2,
                boxWidth / 2, 0, -boxDepth / 2,
                boxWidth / 2, 0, boxDepth / 2,
                -boxWidth / 2, 0, boxDepth / 2,

                // Front face
                -boxWidth / 2, 0, boxDepth / 2,
                boxWidth / 2, 0, boxDepth / 2,
                boxWidth / 2, boxHeight, boxDepth / 2,
                -boxWidth / 2, boxHeight, boxDepth / 2,

                // Back face
                -boxWidth / 2, 0, -boxDepth / 2,
                boxWidth / 2, 0, -boxDepth / 2,
                boxWidth / 2, boxHeight, -boxDepth / 2,
                -boxWidth / 2, boxHeight, -boxDepth / 2,

                // Left face
                -boxWidth / 2, 0, -boxDepth / 2,
                -boxWidth / 2, boxHeight, -boxDepth / 2,
                -boxWidth / 2, boxHeight, boxDepth / 2,
                -boxWidth / 2, 0, boxDepth / 2,

                // Right face
                boxWidth / 2, 0, -boxDepth / 2,
                boxWidth / 2, boxHeight, -boxDepth / 2,
                boxWidth / 2, boxHeight, boxDepth / 2,
                boxWidth / 2, 0, boxDepth / 2,
            ];

            const indices = [
                0, 1, 2, 2, 3, 0,      // Bottom
                4, 5, 6, 6, 7, 4,      // Front
                8, 9, 10, 10, 11, 8,    // Back
                12, 13, 14, 14, 15, 12,  // Left
                16, 17, 18, 18, 19, 16   // Right
            ];

            openTopBoxGeometry.setIndex(indices);
            openTopBoxGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            openTopBoxGeometry.computeVertexNormals();

            let boxMaterial = new THREE.MeshBasicMaterial({ color: brownColor, side: THREE.DoubleSide });
            box = new THREE.Mesh(openTopBoxGeometry, boxMaterial);
            box.position.set(4, 0.5, -2);
            scene.add(box);

            // Add outline
            const outlineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            const outlineGeometry = new THREE.EdgesGeometry(openTopBoxGeometry);
            const outline = new THREE.LineSegments(outlineGeometry, outlineMaterial);
            box.add(outline);
            scene.add(box);

            const light = new THREE.PointLight(0xffffff, 1, 100);
            light.position.set(5, 5, 5);
            scene.add(light);

            pointGeometry = new THREE.PlaneGeometry(0.05, 0.05);
            pointMaterial = new THREE.MeshBasicMaterial({ color: currentColor });

            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Load sound effects
            for (const key in soundFiles) {
                loadSound(soundFiles[key], function (buffer) {
                    soundBuffers[key] = buffer;
                });
            }

            handElement = document.getElementById('hand');
            if (handElement) {
                handElement.style.display = 'block';
            }

            // Add cylinders to the scene
            const cylinderGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 32);
            const materials = [0x00ff00, 0x0000ff, 0xff0000].map(color => new THREE.MeshBasicMaterial({ color }));

            for (let i = 0; i < 3; i++) {
                let cylinder = new THREE.Mesh(cylinderGeometry, materials[i]);
                cylinder.position.set(4 + (i * 0.2 - 0.2), 1.5, -2);
                scene.add(cylinder);
                cylinders.push(cylinder);
            }

            // Get joystick elements
            joystick = document.getElementById('joystick');
            joystickHandle = document.getElementById('joystick-handle');
            if (joystick && joystickHandle) {
                // Store the center position of the joystick
                const rect = joystick.getBoundingClientRect();
                joystickCenter = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };

                 // Add touch listeners for mobile
                joystickHandle.addEventListener('touchstart', handleJoystickStart, { passive: false });
                joystickHandle.addEventListener('touchmove', handleJoystickMove, { passive: false });
                joystickHandle.addEventListener('touchend', handleJoystickEnd, { passive: false });

                // Add mouse listeners
                joystickHandle.addEventListener('mousedown', handleJoystickStart);
                joystickHandle.addEventListener('mousemove', handleJoystickMove);
                joystickHandle.addEventListener('mouseup', handleJoystickEnd);
                document.addEventListener('mouseup', handleJoystickEnd); //global
            }


            // Event Listeners
            document.addEventListener("keydown", (event) => {
                switch (event.key) {
                    case "ArrowLeft": rotateLeft = true; break;
                    case "ArrowRight": rotateRight = true; break;
                    case "ArrowUp": rotateUp = true; break;
                    case "ArrowDown": rotateDown = false; break;
                }
            });

            document.addEventListener("keyup", (event) => {
                switch (event.key) {
                    case "ArrowLeft": rotateLeft = false; break;
                    case "ArrowRight": rotateRight = false; break;
                    case "ArrowUp": rotateUp = false; break;
                    case "ArrowDown": rotateDown = false; break;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDrawing) {
                    spray(e.clientX, e.clientY);
                }
                updateHandPosition(e);
                mouse.set(
                    (e.clientX / window.innerWidth) * 2 - 1,
                    -(e.clientY / window.innerHeight) * 2 + 1
                );
            });

             document.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left mouse button
                    isLeftMouseDown = true;
                    isDrawing = true;
                    spray(e.clientX, e.clientY);
                    playSpraySound();
                }
                if (e.button === 2) {  // Right click - now just prevents context menu
                    e.preventDefault();
                    return;
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) { // Left mouse button
                    isLeftMouseDown = false;
                    isDrawing = false;
                    playSpraySound(); // Stop spray sound when left mouse button is released
                }
                if (e.button === 2 && pickedCylinder) {
                    return;
                }
            });

            document.addEventListener('dblclick', (e) => {
                e.preventDefault();
                handlePickupOrDrop(e);
            });

            document.addEventListener('mouseout', () => {
                isDrawing = false;
                isLeftMouseDown = false;
                playSpraySound();
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        function handlePickupOrDrop(event) {
             if (pickedCylinder) {
                pickedCylinder = null;
                playSound('drop');
                return;
            }

            mouse.set(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cylinders);

            if (intersects.length > 0) {
                pickedCylinder = intersects[0].object;
                playSound('capOff');
            }
        }

        function updateHandPosition(event) {
            if (!event) return;
            const currentHandPosition = { x: event.clientX, y: event.clientY };
            const handSpeed = Math.sqrt(
                Math.pow(currentHandPosition.x - lastHandPosition.x, 2) +
                Math.pow(currentHandPosition.y - lastHandPosition.y, 2)
            );

            if (pickedCylinder && !isLeftMouseDown && handSpeed > 30) { // Increased sensitivity to 30
                if (!isShaking) {
                    isShaking = true;
                    playShakingSound();
                }
                // Clear timeout if it exists
                if (shakeTimeout) {
                    clearTimeout(shakeTimeout);
                }
                //reset last position
                shakeTimeout = setTimeout(() => {
                    lastHandPosition = {x: currentHandPosition.x, y: currentHandPosition.y};
                    isShaking = false;
                    playShakingSound();
                }, 200);

            }
            else{
                lastHandPosition = { x: event.clientX, y: event.clientY };
                if(isShaking){
                    isShaking = false;
                    playShakingSound();
                }
            }


            handElement.style.left = `${event.clientX - handElement.offsetWidth / 2}px`;
            handElement.style.top = `${event.clientY - handElement.offsetHeight / 2}px`;

            if (pickedCylinder) {
                let vector = new THREE.Vector3(
                    (event.clientX / window.innerWidth) * 2 - 1,
                    -(event.clientY / window.innerHeight) * 2 + 1,
                    0.5
                );
                vector.unproject(camera);
                let dir = vector.sub(camera.position).normalize();
                let distance = 2;
                let newPos = camera.position.clone().add(dir.multiplyScalar(distance));
                pickedCylinder.position.copy(newPos);
            }
        }

        function updatePlayerPosition() {
            let speed = 0.1;
            velocity.set(0, 0, 0);

            // Use joystick input
            if (joystickInput.y > 0.1) velocity.z -= speed;  // Forward
            if (joystickInput.y < -0.1) velocity.z += speed; // Backward
            if (joystickInput.x < -0.1) velocity.x -= speed; // Left
            if (joystickInput.x > 0.1) velocity.x += speed; // Right

            direction.copy(velocity).normalize();
            player.position.add(direction.multiplyScalar(speed));

            if (rotateLeft) {
                cameraRotationY += rotationSpeed;
            }
            if (rotateRight) {
                cameraRotationY -= rotationSpeed;
            }
            if (rotateUp) {
                cameraRotationX += rotationSpeed;
            }
            if (rotateDown) {
                cameraRotationX -= rotationSpeed;
            }

            player.rotation.y = cameraRotationY;
            cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));
            camera.rotation.x = cameraRotationX;

            cameraTarget.copy(player.position);
            cameraTarget.x += Math.sin(cameraRotationY) * targetDistance;
            cameraTarget.z += Math.cos(cameraRotationY) * -targetDistance;
            cameraTarget.y += Math.sin(cameraRotationX) * targetDistance;
            camera.lookAt(cameraTarget);
        }

        function spray(x, y) {
            mouse.set(
                (x / window.innerWidth) * 2 - 1,
                -(y / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(wall);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                for (let i = 0; i < numPoints; i++) {
                    const offsetX = (Math.random() - 0.5) * sprayRadius;
                    const offsetY = (Math.random() - 0.5) * sprayRadius;
                    const offsetZ = (Math.random() - 0.5) * sprayRadius;
                    const sprayX = point.x + offsetX;
                    const sprayY = point.y + offsetY;
                    const sprayZ = point.z + offsetZ;

                    sprayPoints.push({ x: sprayX, y: sprayY, z: sprayZ, color: currentColor });
                }
                playSpraySound();
            }
        }

        function drawSpray() {
            sprayPoints.forEach(p => {
                const spraySquare = new THREE.Mesh(pointGeometry, pointMaterial);
                spraySquare.position.set(p.x, p.y, p.z);
                spraySquare.lookAt(camera.position);
                scene.add(spraySquare);
            });
            sprayPoints.length = 0;
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlayerPosition();
            updateHandPosition();
            drawSpray();
            renderer.render(scene, camera);
        }

        function handleJoystickStart(event) {
            event.preventDefault(); // Prevents additional mouse events
            isDraggingJoystick = true;
            if (event.changedTouches && event.changedTouches[0]) {
                const touch = event.changedTouches[0];
                 joystickHandle.style.left = `${touch.clientX - joystickHandle.offsetWidth / 2}px`;
                 joystickHandle.style.top = `${touch.clientY - joystickHandle.offsetHeight / 2}px`;
            }
            else{
                 joystickHandle.style.left = `${event.clientX - joystickHandle.offsetWidth / 2}px`;
                 joystickHandle.style.top = `${event.clientY - joystickHandle.offsetHeight / 2}px`;
            }

        }

       function handleJoystickMove(event) {
            if (!isDraggingJoystick) return;

            event.preventDefault(); // Prevent page scroll on mobile

            let clientX, clientY;
            if (event.changedTouches && event.changedTouches[0]) {
                const touch = event.changedTouches[0];
                clientX = touch.clientX;
                clientY = touch.clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const deltaX = clientX - joystickCenter.x;
            const deltaY = clientY - joystickCenter.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 50; // Maximum distance the handle can move from the center

            // Normalize the delta values to get a direction vector
            let x = deltaX / distance;
            let y = deltaY / distance;

            // Clamp the distance to the maximum
            if (distance > maxDistance) {
                x *= maxDistance / distance;
                y *= maxDistance / distance;
            }

            joystickInput.x = x / maxDistance;
            joystickInput.y = y / maxDistance;

            // Update handle position, clamping within the joystick bounds
            const handleX = joystickCenter.x + x * maxDistance - joystickHandle.offsetWidth / 2;
            const handleY = joystickCenter.y + y * maxDistance - joystickHandle.offsetHeight / 2;

            joystickHandle.style.left = `${handleX}px`;
            joystickHandle.style.top = `${handleY}px`;

            // Update movement flags based on joystick input
            moveForward = joystickInput.y < -0.1;
            moveBackward = joystickInput.y > 0.1;
            moveLeft = joystickInput.x < -0.1;
            moveRight = joystickInput.x > 0.1;
        }

        function handleJoystickEnd(event) {
            event.preventDefault();
            isDraggingJoystick = false;
            joystickInput.x = 0;
            joystickInput.y = 0;
            // Reset handle position to the center
            joystickHandle.style.left = `${joystickCenter.x - joystickHandle.offsetWidth / 2}px`;
            joystickHandle.style.top = `${joystickCenter.y - joystickHandle.offsetHeight / 2}px`;

            // Reset movement flags
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
        }

        init();
    </script>
</body>
</html>
